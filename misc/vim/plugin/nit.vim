" This file is part of NIT ( http://www.nitlanguage.org ).
"
" Licensed under the Apache License, Version 2.0 (the "License");
" you may not use this file except in compliance with the License.
" You may obtain a copy of the License at
"
"		 http://www.apache.org/licenses/LICENSE-2.0
"
" Unless required by applicable law or agreed to in writing, software
" distributed under the License is distributed on an "AS IS" BASIS,
" WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
" See the License for the specific language governing permissions and
" limitations under the License.

" Nit plugin for Vim, provides some advanced features

if v:version < 700
	finish
endif

if exists("loaded_nit_plugin")
	finish
endif
let loaded_nit_plugin = 1

" Scan all relevant Nit modules for the current directory to autocomplete
"
" The guard `g:nit_complete_done` ensures that its body is executed only
" once. The call to `nitls -M` analyzses the current directory. However,
" updating the module list can be forced using ForceNitComplete.
"
" To activate, add the following line to ~/.vimrc
"
" autocmd Filetype nit call NitComplete()
function NitComplete()
	if !exists("g:nit_complete_done")
		let g:nit_complete_done = 1

		" Reset or backup the original complete
		if !exists("g:nit_complete_backup")
			let g:nit_complete_backup = &complete
		else
			silent let &complete = g:nit_complete_backup
			silent set complete?
		endif

		" This gives us better results for Nit
		set noignorecase
		set completeopt=longest,menuone,preview

		" Do not predict small 3 letters keywords (or their prefix), they slow down
		" prediction and some also require double-enter on end of line.
		let g:acp_behaviorKeywordIgnores = ['new', 'var', 'in', 'do', 'els', 'end', 'ret', 'for', 'fun']

		" Use nitls to compute all interesting files from the current directory and the standard library
		for file in split(system('nitls -M standard .', '\n'))
			silent let &complete = &complete . ',s' . file
			silent set complete?
		endfor

		" Compatibility with AutoComplPop
		let g:acp_completeOption = &complete
		let g:acp_ignorecaseOption = &ignorecase

		" Redraw in case the user pressed some keys while waiting
		redraw!
	endif
endfunction

" Force updating the Nit modules used for autocomplete
"
" It is recommended to manually call this function as needed. It can be mapped
" to a key with:
"
" map <F2> :call ForceNitComplete()
"
" For small projects (or fast computers) you might want to call it on each
" file save or load.
function ForceNitComplete()
	unlet! g:nit_complete_done
	call NitComplete()
endfunction

" Internal function to search for lines in `path` corresponding to the partial
" word `base`. Adds found and formated match to `matches`.
fun NitOmnifuncAddFromFile(base, matches, path)
	for line in readfile(a:path)
		let words = split(line, '#====#', 1)
		let name = get(words, 0, '')
		if name =~ a:base
			let pretty = get(words, 1, '')
			let synopsis = get(words, 2, '')
			let desc = get(words, 3, '')
			let desc = join(split(desc, '#nnnn#', 1), "\n")
			if strlen(pretty) > 40
				let pretty = pretty[:37] . '...'
			endif
			call add(a:matches, {'word': name, 'abbr': pretty, 'menu': synopsis, 'info': desc, 'dup': 1})
		endif
	endfor
endfun

" Omnifunc using metadata files generated by nitpick to offer better
" contextual autocomplete for Nit source code.
fun NitOmnifunc(findstart, base)
	if a:findstart
		" locate the start of the word
		let line = getline('.')
		let start = col('.') - 1
		while start > 0 && line[start - 1] =~ '\w'
			let start -= 1
		endwhile
		return start
	else
		" find keyword matching with "a:base"
		let matches = []

		" Advanced suggestions
		let cursor_line = getline('.')

		" Content of the line before the partial word
		let line_prev_cursor = cursor_line[:col('.')-1]

		" Char just before the partial word
		let prev_char = line_prev_cursor[-1:]

		" Nity words on the current line before the partial word
		let prev_words = split(line_prev_cursor, '\W\+')

		" The word right before the partial word
		let prev_word = get(prev_words, -1, '')

		" Have we found a promising heuristic yet?
		let handled = 0

		" Modules
		if prev_word == 'import'
			let handled = 1
			call NitOmnifuncAddFromFile(a:base, matches, 'modules.txt')
		endif

		" Classes
		if count(['new', 'super', 'class'], prev_word) > 0
			let handled = 1
			call NitOmnifuncAddFromFile(a:base, matches, 'classes.txt')
		endif

		" Properties
		if prev_char == '.'
			let handled = 1
			call NitOmnifuncAddFromFile(a:base, matches, 'properties.txt')
		endif

		" If is nothing else...
		if !handled
			" it may be a keyword
			if strlen(a:base) > 0
				for keyword in ['module', 'import', 'class', 'abstract', 'interface',
					\'universal', 'enum', 'end', 'fun', 'type', 'init', 'redef', 'is',
					\'do', 'var', 'extern', 'public', 'protected', 'private', 'intrude',
					\'if', 'then', 'else', 'while', 'loop', 'for', 'in', 'and', 'or',
					\'not', 'implies', 'return', 'continue', 'break', 'abort', 'assert',
					\'new', 'isa', 'once', 'super', 'self', 'true', 'false', 'null',
					\'as', 'nullable', 'isset', 'label']

					if keyword =~ '^' . a:base
						call add(matches, keyword)
					endif
				endfor
			endif

			" it may still be a method call or property access
			call NitOmnifuncAddFromFile(a:base, matches, 'properties.txt')
		endif

		return {'words': matches, 'refresh': 'always'}
	endif
endfun

" Activate the omnifunc on Nit files
autocmd FileType nit set omnifunc=NitOmnifunc
